<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Dempsey Dong">


    <meta name="subtitle" content="Dempsey">


    <meta name="description" content="Always believe tomorrow.">



<title>Java-基础（补缺） | Studty Log</title>



    <link rel="icon" href="/Dempsey.github.io/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/Dempsey.github.io/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/Dempsey.github.io/js/script.js"></script>
    
    <script src="/Dempsey.github.io/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.0.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/Dempsey.github.io/">Dempsey&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/Dempsey.github.io/archives">Posts</a>
                
                    <a class="menu-item" href="/Dempsey.github.io/category">Categories</a>
                
                    <a class="menu-item" href="/Dempsey.github.io/tag">Tags</a>
                
                    <a class="menu-item" href="/Dempsey.github.io/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/Dempsey.github.io/">Dempsey&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/Dempsey.github.io/archives">Posts</a>
                
                    <a class="menu-item" href="/Dempsey.github.io/category">Categories</a>
                
                    <a class="menu-item" href="/Dempsey.github.io/tag">Tags</a>
                
                    <a class="menu-item" href="/Dempsey.github.io/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Java-基础（补缺）</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Dempsey Dong</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">一月 3, 2024&nbsp;&nbsp;16:54:44</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/Dempsey.github.io/categories/Java-Note/">Java-Note</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="1-Java-基础数据类型缓存池"><a href="#1-Java-基础数据类型缓存池" class="headerlink" title="1. Java 基础数据类型缓存池"></a>1. Java 基础数据类型缓存池</h2><p>主要的区别点在识别出<code>Integer.valueOf(18) 与 new Integer(18)</code>的不同，了解</p>
<p>在Java中，JVM初始化的时候会对一些数据类型(Integer，Long，Boolean等)进行初始化，将一些常用的对象缓存在内存中，以提高程序的性能和节省重复的内存开销。但是这些缓存是有数据范围限制的，超出范围的都将以新对象返回。但是使用缓存池里的对象的时候会存在不同线程同时修改的同步问题，所以需要特定业务进行特定分析。</p>
<h3 id="哪些数据类型有缓存池"><a href="#哪些数据类型有缓存池" class="headerlink" title="哪些数据类型有缓存池"></a>哪些数据类型有缓存池</h3><ul>
<li>Byte：-128~127，也就是所有的 byte 值</li>
<li>Short：-128~127</li>
<li>Long：-128~127</li>
<li>Character：\u0000 - \u007F</li>
<li>Boolean：true 和 false</li>
</ul>
<h3 id="缓存池的主要用法"><a href="#缓存池的主要用法" class="headerlink" title="缓存池的主要用法"></a>缓存池的主要用法</h3><p>主要内容为区别以下三段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">18</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">18</span>);</span><br><span class="line">System.out.println(x == y);</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">18</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">18</span>);</span><br><span class="line">System.out.println(z == k);</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> Integer.valueOf(<span class="number">300</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">p</span> <span class="operator">=</span> Integer.valueOf(<span class="number">300</span>);</span><br><span class="line">System.out.println(m == p);</span><br></pre></td></tr></table></figure>

<p>第一段代码的结果是<code>false</code>，是每次都实例化一个Integer对象，并且将其内容设置为18。而第二段代码的结果是<code>true</code>是使用Integer自带的缓冲池里面的value来实例化一个对象，其方法内容代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果传入的值介于缓存池的最值之间，直接返回Cache里面的对象；</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;=IntegerCache.low &amp;&amp; i &lt;=IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="comment">// 否则新建一个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三段代码得到的结果是<code>false</code>，原因是对于Integer类来说，其缓存加载的数据范围为-128~127，300超过了这个范围，所以就不一样。</p>
<h2 id="2-Java-位运算符"><a href="#2-Java-位运算符" class="headerlink" title="2. Java 位运算符"></a>2. Java 位运算符</h2><p>特殊的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 &lt;&lt; 2 = 40 // 相当于是10 * 2^2 = 40</span><br><span class="line">20 &gt;&gt; 3 = 2 // 相当于是 20 / 2^3 = 2</span><br></pre></td></tr></table></figure>

<h2 id="3-数组相关的缺漏"><a href="#3-数组相关的缺漏" class="headerlink" title="3. 数组相关的缺漏"></a>3. 数组相关的缺漏</h2><h3 id="字符串数组在函数参数传递中的作用"><a href="#字符串数组在函数参数传递中的作用" class="headerlink" title="字符串数组在函数参数传递中的作用"></a>字符串数组在函数参数传递中的作用</h3><p>和Python一样，对于以下的函数<code>varargsMethod()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarargsDemo</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VarargsDemo</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title function_">varargsMethod</span><span class="params">(String as[])</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的as可以输入一个String数组，也可以输入两个字符串如下的调用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VarargsDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VarargsDemo</span>();</span><br><span class="line">String[] anArray = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;沉默王二&quot;</span>, <span class="string">&quot;一枚有趣的程序员&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 直接输入数组，把其直接给as</span></span><br><span class="line">demo.varargsMethod(anArray);</span><br><span class="line"><span class="comment">// 输入两个String，把他们一起作为as的内容</span></span><br><span class="line">demo.varargsMethod(<span class="string">&quot;沉默王二&quot;</span>, <span class="string">&quot;一枚有趣的程序员&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="常用的方法-排序，二分查找"><a href="#常用的方法-排序，二分查找" class="headerlink" title="常用的方法(排序，二分查找)"></a>常用的方法(排序，二分查找)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] anArray = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br><span class="line">Arrays.sort(anArray);</span><br><span class="line">Arrays.sort(yetAnotherArray, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">//只对 1-3 位置上的元素进行反序</span></span><br><span class="line">                Comparator.comparing(String::toString).reversed());</span><br><span class="line"><span class="comment">// 可以重载Comparator来对排序进行操作。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(anArray, <span class="number">4</span>); <span class="comment">// 通过排序好的数组进行二分查找获得下标。</span></span><br></pre></td></tr></table></figure>

<h3 id="数组怎么输出"><a href="#数组怎么输出" class="headerlink" title="数组怎么输出"></a>数组怎么输出</h3><p>因为数组也是一个对象，因为其直接打印出来是Object的toString()方法；</p>
<ul>
<li>使用Arrays打印数组。<br>  Arrays.toString()可以将所有的数据类型的数组转为输出。<br>  二维数组用deepToString();</li>
</ul>
<h2 id="4-String-源码阅读及相关内容"><a href="#4-String-源码阅读及相关内容" class="headerlink" title="4. String 源码阅读及相关内容"></a>4. String 源码阅读及相关内容</h2><h3 id="String-的定义："><a href="#String-的定义：" class="headerlink" title="String 的定义："></a>String 的定义：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>意味着：</p>
<ol>
<li>final 表明方法无法继续被继承；</li>
<li>Serializable 表明String是可以被序列化存储的；</li>
<li>Comparable 表明不能用‘&#x3D;&#x3D;’来判断是否相等；</li>
</ol>
<h3 id="编码特性"><a href="#编码特性" class="headerlink" title="编码特性"></a>编码特性</h3><p>在 Java9 以后，String内部的value变成了用byte[] 数组存储的，而不是char[]。这样带来的相关影响<br>    - 只能使用 8 个bit来表示字符，一共是 256 个；<br>    - 相比于占用 16 个bit的char来说，其间断了 String 将近一半的空间；<br>    - 与此同时带来的是，String需要对字符的编码进行识别，coder。默认为 Latin-1.<br>    - String name &#x3D; “jack” 只需要 4个字节而 “董明龙” 需要 6 个字节，因为中文使用 UTF16 编码。</p>
<h3 id="String-的-Hash"><a href="#String-的-Hash" class="headerlink" title="String 的 Hash"></a>String 的 Hash</h3><p>每一个字符串都会有一个 Hash 值，其计算方式为 31的倍数法，<code>h = 31 * h + val[i];</code>即 <code>H(s) = (s[0] * 31^(n-1)) + (s[1] * 31^(n-2)) + ... + (s[n-1] * 31^0)</code></p>
<h3 id="String-的-subString"><a href="#String-的-subString" class="headerlink" title="String 的 subString()"></a>String 的 subString()</h3><ol>
<li>只有一个参数的时候是 从index到末尾的字符串；</li>
<li>有两个参数的时候是 [index1, index2) 截取的字符串；</li>
<li>trim() 可以消除两边的空格。</li>
</ol>
<h3 id="String-里indexof-查找子串的方法源码分析"><a href="#String-里indexof-查找子串的方法源码分析" class="headerlink" title="String 里indexof() 查找子串的方法源码分析"></a>String 里indexof() 查找子串的方法源码分析</h3><p>流程为：</p>
<ol>
<li>判断各个输入值是否为有效的；</li>
<li>从 beginIndex 到 source.length - target.length 之间的区间里面去按照 遍历 的方式找到第一个字符；</li>
<li>找到第一个字符以后，继续匹配后面的字符是否匹配target，全部匹配则继续，否则继续回到2；</li>
<li>遍历索引超过最大值，没有找到返回 -1.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找字符数组 target 在字符数组 source 中第一次出现的位置。</span></span><br><span class="line"><span class="comment"> * sourceOffset 和 sourceCount 参数指定 source 数组中要搜索的范围，</span></span><br><span class="line"><span class="comment"> * targetOffset 和 targetCount 参数指定 target 数组中要搜索的范围，</span></span><br><span class="line"><span class="comment"> * fromIndex 参数指定开始搜索的位置。</span></span><br><span class="line"><span class="comment"> * 如果找到了 target 数组，则返回它在 source 数组中的位置索引（从0开始），</span></span><br><span class="line"><span class="comment"> * 否则返回-1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">char</span>[] source, <span class="type">int</span> sourceOffset, <span class="type">int</span> sourceCount,</span></span><br><span class="line"><span class="params">        <span class="type">char</span>[] target, <span class="type">int</span> targetOffset, <span class="type">int</span> targetCount,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> fromIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果开始搜索的位置已经超出 source 数组的范围，则直接返回-1（如果 target 数组为空，则返回 sourceCount）</span></span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</span><br><span class="line">        <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果开始搜索的位置小于0，则从0开始搜索</span></span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fromIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 target 数组为空，则直接返回开始搜索的位置</span></span><br><span class="line">    <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fromIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 target 数组的第一个字符在 source 数组中的位置</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">first</span> <span class="operator">=</span> target[targetOffset];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> sourceOffset + (sourceCount - targetCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环查找 target 数组在 source 数组中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="comment">/* Look for first character. */</span></span><br><span class="line">        <span class="comment">// 如果 source 数组中当前位置的字符不是 target 数组的第一个字符，则在 source 数组中继续查找 target 数组的第一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (source[i] != first) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Found first character, now look at the rest of v2 */</span></span><br><span class="line">        <span class="comment">// 如果在 source 数组中找到了 target 数组的第一个字符，则继续查找 target 数组的剩余部分是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> j + targetCount - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class="line">                    == target[k]; j++, k++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 target 数组全部匹配，则返回在 source 数组中的位置索引</span></span><br><span class="line">            <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                <span class="comment">/* Found whole string. */</span></span><br><span class="line">                <span class="keyword">return</span> i - sourceOffset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到 target 数组，则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="String-的不变性"><a href="#String-的不变性" class="headerlink" title="String 的不变性"></a>String 的不变性</h3><ol>
<li>首先String被final修饰，不可被继承；</li>
<li>其次String的value数组也被final修饰了，不可以被修改；<br>因此 String 具有不变性，在其初始化的时候就确定了其内部的值。</li>
</ol>
<p>设计的原因是：<br>    - 保证String使用的安全性，因为String通常存储一些需要安全保障的字符串。这样可以保障其不被随机篡改。<br>    - 因为在之前提到了String有HashCode的计算，如果频繁的修改String的值会出现hash表的性能降低。（Case：如果初始化了两个一样内容的String，那么其都会指向相同的常量池的内容。第二次初始化的时候就不需要再次计算Hash的值，而是直接使用。）<br>    - 可以保障字符串常量池的实现。Java会将初始化后的字符串的内容放在字符串常量池中，如果后面有相同的字符串变量可以直接使用这个在常量池里面的字符串，直接引用其对象即可。**基于此，String的很多方法基本上都是新建了一个新的字符串(new String())进行返回，而不是返回修改后的String(它也不可以被修改, 原来的字符串还是一样的值)**。</p>
<h3 id="深入理解-String-的字符串常量池"><a href="#深入理解-String-的字符串常量池" class="headerlink" title="深入理解 String 的字符串常量池"></a>深入理解 String 的字符串常量池</h3><ol>
<li><p>双引号和new的区别：</p>
<ul>
<li>new 一个对象（String s &#x3D; new String(“DML”)）会首先在字符串常量里面新建一个DML的字符串常量，然后再在堆里面再新建一个String对象，其内容也是 “DML”。然后把在堆里新建的这个对象的引用传给 放在Java栈里面的 引用s。如下图中的上图表示。</li>
<li>new 一个已经被 new 过的对象（String s2 &#x3D; new String(“DML”)）,此时将不会再在常量池里面添加一个新的DML字符串常量了，而是直接在堆里面创建一个字符串常量并且将其引用传给栈里面的 引用s。如下图的下图表示。</li>
</ul>
<p> <img src="/Dempsey.github.io/2024/01/03/Java-DataStructure/image.png" alt="图示1"></p>
<ul>
<li>而用双引号来初始化的时候，如果 String s &#x3D; “DML1”，中的DML1还不存在String的字符串常量中，那么Java不会在堆中创建一个字符串对象了，而是直接在字符串常量池里面新建一个”DML1”对象，并且将其地址送给栈中的 引用s；</li>
<li>如果”DML1”已经存在了，那么直接把该对象的地址送给引用，而不会有其他的新建操作了。</li>
</ul>
<p> <img src="/Dempsey.github.io/2024/01/03/Java-DataStructure/image1.png" alt="图示2"></p>
</li>
<li><p>为什么要有字符串常量池？<br> 因为字符串在实际的开发和代码编写的过程中被使用的频率非常高，每次都重复的新建一个对象会一定长度上不及使用常量池来做的效率。所以 JVM 为了提高性能和减少内存开销，在创建字符串对象的时候进行了一些优化，特意为字符串开辟了一块空间——也就是字符串常量池。</p>
</li>
</ol>
<h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h3><p>重点在理解Java7以及以后的如何操作intern();</p>
<p>首先需要明白的是 String.intern() 会返回一个地址，如果String的内容在字符串常量池中存在，那么就直接使用即可。但是如果内容不存在在字符串常量池，java6会将其字符串再次在perm区里面创建并且返回其引用。如果是java7则会将原本在堆里面创建的对象的地址维护在字符串常量池中。<br>如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="comment">// 这一行代码一共创建了 4 个对象，首先是字符串常量池里面的 &quot;1&quot;, 然后是在堆里面的两个内容为 &quot;1&quot; 的匿名对象。最后是在堆里面再次创建了一个内容为&quot;11&quot;的对象，s直接引用的是这个字符串。</span></span><br><span class="line"><span class="comment">// 这里的 &quot;11&quot; 的对象创建是利用了StringBuilder的！！！！！</span></span><br><span class="line">s.intern();</span><br><span class="line"><span class="comment">// 调用intern()实现将 11 存入 字符串常量池。java6会在字符串常量池里面直接新建该新对象，而java7则会把这个堆里面的对象的引用维护在常量池里面。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line"><span class="comment">// 在java6里面因为”11“已经被放入perm区，所以直接引用其常量</span></span><br><span class="line"><span class="comment">// 而在java7以后没有perm区，&quot;11&quot;不会直接被创建而是会指向堆里面的 &quot;11&quot;</span></span><br><span class="line">System.out.println(s == s2);</span><br><span class="line"><span class="comment">// java6里面是false，java7里面是true。</span></span><br></pre></td></tr></table></figure>

<p>用处（优点）：<br>在海量数据且有重复使用字符串数据的时候减少内存使用，但这在一定程度上也增加了代码运行时间的开销，在大量数据处理的场景下也是可以接受的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(DB_DATA[i % DB_DATA.length]));</span><br><span class="line">arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(DB_DATA[i % DB_DATA.length])).intern();</span><br></pre></td></tr></table></figure>
<p>这两段代码的区别就是下面的内存占用比上面少了近 100w 倍，因为其一直返回的都是常量池的引用，而不是堆里面的匿名对象的内容。<br><a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">具体详细解释(美团技术团队)</a></p>
<h3 id="String的”-”操作"><a href="#String的”-”操作" class="headerlink" title="String的”+”操作"></a>String的”+”操作</h3><ol>
<li>如果是变量，则会使用<code>StringBuilder().append(a).append(b).toString()</code>来返回新的字符串；</li>
<li>如果是常量相加，会出现常量折叠的情况<code>String s = &quot;1&quot; + &quot;2&quot; -&gt; String s = &quot;12&quot;;</code>会直接在编译的时候变成一组字符串。</li>
</ol>
<h3 id="String-例题"><a href="#String-例题" class="headerlink" title="String 例题"></a>String 例题</h3><p>字符串加法：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-strings/description/">题目</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> num1.length(), len2 = num2.length();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">addiation</span> <span class="operator">=</span> <span class="number">0</span>, reslen = Math.max(len1, len2);</span><br><span class="line">        <span class="comment">// 需要选择可变的变量类型StringBuilder();</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">iter</span> <span class="operator">=</span> <span class="number">1</span> ; iter &lt;= reslen ; iter ++) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">temp1</span> <span class="operator">=</span> iter &lt;= len1 ? Integer.valueOf(num1.charAt(len1 - iter) - <span class="string">&#x27;0&#x27;</span>):<span class="number">0</span>;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">temp2</span> <span class="operator">=</span> iter &lt;= len2 ? Integer.valueOf(num2.charAt(len2 - iter) - <span class="string">&#x27;0&#x27;</span>):<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> temp1 + temp2 + addiation;</span><br><span class="line">            addiation = sum / <span class="number">10</span>;</span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            res.append(sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (addiation != <span class="number">0</span>) res.append(addiation);</span><br><span class="line">        res.reverse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-String-的不变性的衍生类-StringBuilder和StringBuffer"><a href="#5-String-的不变性的衍生类-StringBuilder和StringBuffer" class="headerlink" title="5. String 的不变性的衍生类 StringBuilder和StringBuffer"></a>5. String 的不变性的衍生类 StringBuilder和StringBuffer</h2><p>首先 由于 String 的不可继承不可被修改的特性，一旦其被创建以后就不能够被修改了！所以就衍生了 StringBuffer，这个是在一个内容长度可以被扩展，并且是线程安全(append方法被Synchronized修饰)的类。当使用String之间的”+”来操作字符串的时候会自动被解释为append()方法。</p>
<p>StringBuiler更为常见，因为它相对于StringBuffer更加边界，它舍弃了线程同步的问题，所以是线程不安全的。二者都继承于AbstractStringBuiler且不可被继承（final修饰），方法内容都基本上一模一样只是方法没有被同步修饰。如果需要在此基础上实现线程安全，可以使用ThreadLocal来实现。</p>
<p>对于二者扩张字符串的append(str)方法，源码流程</p>
<ol>
<li>判断str是否为空，是则直接进入appendNull()方法；</li>
<li>获取str的长度，判断其长度是否超过容量(初始值是16)；<ul>
<li>进入ensureCapacityInternal(count + str.length), 现在需要这么多的内存，去确认是否现在有那么多的内存；</li>
<li>没有继续进入 expandCapacity(count + str.length)方法, 首先是将原始字符串的长度 * 2 + 2，判断是否到达了count + str.length长度，如果没有则直接创建新的count + str.length长度的数组。</li>
<li>创建新的数组使用Arrays.copyOf(old, newCapacity)方法来实现。</li>
</ul>
</li>
<li>返回</li>
</ol>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Dempsey Dong</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://dempsey1201.github.io/Dempsey.github.io/2024/01/03/Java-DataStructure/">https://dempsey1201.github.io/Dempsey.github.io/2024/01/03/Java-DataStructure/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Everything will be the <strong>BEST</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/Dempsey.github.io/tags/Java/"># Java</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/Dempsey.github.io/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/Dempsey.github.io/2024/01/04/algorithm-12/">Leetcode 236. 二叉树的最近公共祖先</a>
            
            
            <a class="next" rel="next" href="/Dempsey.github.io/2024/01/02/algorithm-11/">Leetcode 102. 二叉树的层序遍历</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Dempsey Dong | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>